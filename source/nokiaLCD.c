/*
 * nokiaLCD.c
 *
 *  Created on: Aug 10, 2021
 *      Author: edgardo
 */

#include "nokiaLCD.h"
#include "MK64F12.h"
#include "fsl_clock.h"
#include "fsl_port.h"
#include "fsl_gpio.h"
//#include "fsl_dspi.h"
#include "freertos_spi.h"

static const uint8_t ASCII[][5] =
{
	{0x00, 0x00, 0x00, 0x00, 0x00} // 20
	,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
	,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
	,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
	,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
	,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
	,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
	,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
	,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
	,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
	,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
	,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
	,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
	,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
	,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
	,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
	,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
	,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
	,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
	,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
	,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
	,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
	,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
	,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
	,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
	,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
	,{0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
	,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
	,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
	,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
	,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
	,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
	,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
	,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
	,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
	,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
	,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
	,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
	,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
	,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
	,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
	,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
	,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
	,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
	,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
	,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
	,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
	,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
	,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
	,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
	,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
	,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
	,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
	,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
	,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
	,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
	,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
	,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
	,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
	,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
	,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c Â¥
	,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
	,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
	,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
	,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
	,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
	,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
	,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
	,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
	,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
	,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
	,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
	,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
	,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
	,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j
	,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
	,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
	,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
	,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
	,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
	,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
	,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
	,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
	,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
	,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
	,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
	,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
	,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
	,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
	,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
	,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
	,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
	,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
	,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
	,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e â†
	,{0x00, 0x06, 0x09, 0x09, 0x06} // 7f â†’
};

static uint8_t displayMap[NOKIA_LCD_X * NOKIA_LCD_Y / 8] = {
  0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 bytes cover an 8x12 block in the left corner of the display
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
  0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
  0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
  0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
  0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
  0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
  0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
  0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
  0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
  0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
};


static void nokiaLCD_delay (uint8_t sec);

static void nokiaLCD_gotoXY (int x, int y);

static void nokiaLCD_setPixel(int x, int y, uint8_t bw);


void nokiaLCD_backlight(uint8_t onoff)
{
	if(onoff)
	{
		GPIO_PortSet(NOKIA_LCD_BL_GPIO, 1 << NOKIA_LCD_BL_PIN);
	}
	else
	{
		GPIO_PortClear(NOKIA_LCD_BL_GPIO, 1 << NOKIA_LCD_BL_PIN);
	}
}

void nokiaLCD_write(uint8_t dc, uint8_t data)
{
//	dspi_transfer_t masterXfer;

	if (dc)
	{
		GPIO_PortSet(NOKIA_LCD_DC_GPIO, 1 << NOKIA_LCD_DC_PIN);
	}
	else
	{
		GPIO_PortClear(NOKIA_LCD_DC_GPIO, 1 << NOKIA_LCD_DC_PIN);
	}

//	masterXfer.txData = &data;
//	masterXfer.rxData = NULL;
//	masterXfer.dataSize = 1;
//	masterXfer.configFlags = kDSPI_MasterCtar0 | kDSPI_MasterPcs0 | kDSPI_MasterPcsContinuous;

//	DSPI_MasterTransferBlocking(SPI0, &masterXfer);

	freertos_spi_transfer(freertos_spi0, &data, NULL, 1);
}

void nokiaLCD_initialise(void)
{
    const gpio_pin_config_t pinConfig = {
        kGPIO_DigitalOutput,
        1,
    };

    const port_pin_config_t output_config = {
			kPORT_PullDisable,
			kPORT_FastSlewRate,
			kPORT_PassiveFilterDisable,
			kPORT_OpenDrainDisable,
			kPORT_HighDriveStrength,
			kPORT_MuxAsGpio,
			kPORT_UnlockRegister,
	};

    // reset
    CLOCK_EnableClock(kCLOCK_PortC);
//    PORT_SetPinMux(NOKIA_LCD_RESET_PORT, NOKIA_LCD_RESET_PIN, kPORT_MuxAsGpio);
    PORT_SetPinConfig(NOKIA_LCD_RESET_PORT, NOKIA_LCD_RESET_PIN, &output_config);
    GPIO_PinInit(NOKIA_LCD_RESET_GPIO, NOKIA_LCD_RESET_PIN, &pinConfig);

    CLOCK_EnableClock(kCLOCK_PortC);
//    PORT_SetPinMux(NOKIA_LCD_DC_PORT, NOKIA_LCD_DC_PIN, kPORT_MuxAsGpio);
    PORT_SetPinConfig(NOKIA_LCD_DC_PORT, NOKIA_LCD_DC_PIN, &output_config);
    GPIO_PinInit(NOKIA_LCD_DC_GPIO, NOKIA_LCD_DC_PIN, &pinConfig);

    // backlight
    CLOCK_EnableClock(kCLOCK_PortC);
//	PORT_SetPinMux(NOKIA_LCD_BL_PORT, NOKIA_LCD_BL_PIN, kPORT_MuxAsGpio);
	PORT_SetPinConfig(NOKIA_LCD_BL_PORT, NOKIA_LCD_BL_PIN, &output_config);
	GPIO_PinInit(NOKIA_LCD_BL_GPIO, NOKIA_LCD_BL_PIN, &pinConfig);

//	dspi_master_config_t masterConfig; // LCD sin FreeRTOS

	freertos_spi_config_t masterConfig;

	masterConfig.baudRate = 4000000U;
	masterConfig.clk_pin = NOKIA_LCD_SCLK_PIN;
	masterConfig.cs_pin = NOKIA_LCD_SCE_PIN;
	masterConfig.mosi_pin = NOKIA_LCD_SDIN_PIN;
	masterConfig.miso_pin = 3;
	masterConfig.pin_mux = kPORT_MuxAlt2;
	masterConfig.port = freertos_spi_portD;
	masterConfig.spi_number = freertos_spi0;


//	CLOCK_EnableClock(kCLOCK_PortD);
//
//	PORT_SetPinMux(NOKIA_LCD_SCE_PORT, NOKIA_LCD_SCE_PIN, kPORT_MuxAlt2); // CE
//	PORT_SetPinMux(NOKIA_LCD_SCLK_PORT, NOKIA_LCD_SCLK_PIN, kPORT_MuxAlt2); //SCK
//	PORT_SetPinMux(NOKIA_LCD_SDIN_PORT, NOKIA_LCD_SDIN_PIN, kPORT_MuxAlt2); //MOSI
//	PORT_SetPinMux(PORTD, 3U, kPORT_MuxAlt2); //MISO
//
//	masterConfig.whichCtar = kDSPI_Ctar0;
//	masterConfig.ctarConfig.baudRate = 4000000U;
//	masterConfig.ctarConfig.bitsPerFrame = 8;
//	masterConfig.ctarConfig.cpol = kDSPI_ClockPolarityActiveHigh;
//	masterConfig.ctarConfig.cpha = kDSPI_ClockPhaseFirstEdge;
//	masterConfig.ctarConfig.direction = kDSPI_MsbFirst;
//	masterConfig.ctarConfig.pcsToSckDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.baudRate ;
//	masterConfig.ctarConfig.lastSckToPcsDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.baudRate ;
//	masterConfig.ctarConfig.betweenTransferDelayInNanoSec = 1000000000U / masterConfig.ctarConfig.baudRate ;
//	masterConfig.whichPcs = kDSPI_Pcs0;
//	masterConfig.pcsActiveHighOrLow = kDSPI_PcsActiveLow;
//	masterConfig.enableContinuousSCK = false;
//	masterConfig.enableRxFifoOverWrite = false;
//	masterConfig.enableModifiedTimingFormat = false;
//	masterConfig.samplePoint = kDSPI_SckToSin0Clock;
//
//	DSPI_MasterInit(SPI0, &masterConfig, CLOCK_GetFreq(DSPI0_CLK_SRC));

	freertos_spi_init(masterConfig);

	GPIO_PortClear(NOKIA_LCD_RESET_GPIO, 1 << NOKIA_LCD_RESET_PIN);

    nokiaLCD_delay(1);

	GPIO_PortSet(NOKIA_LCD_RESET_GPIO, 1 << NOKIA_LCD_RESET_PIN);

	nokiaLCD_write(NOKIA_LCD_COMMAND, (0x21 | NOKIA_LCD_CMD_HORADDRS)); //Tell LCD extended commands follow
	nokiaLCD_write(NOKIA_LCD_COMMAND, 0xB9); //Set LCD Vop (Contrast)
	nokiaLCD_write(NOKIA_LCD_COMMAND, 0x04); //Set Temp coefficent
	nokiaLCD_write(NOKIA_LCD_COMMAND, 0x14); //LCD bias mode 1:48 (try 0x13)
	//We must send 0x20 before modifying the display control mode
	nokiaLCD_write(NOKIA_LCD_COMMAND, (0x20 | NOKIA_LCD_CMD_HORADDRS));
	nokiaLCD_write(NOKIA_LCD_COMMAND, 0x0C); //Set display control, normal mode.
}

void nokiaLCD_updateDisplay (void)
{
	nokiaLCD_gotoXY(0, 0);
	for (int i=0; i < (NOKIA_LCD_X * NOKIA_LCD_Y / 8); i++)
	{
		 nokiaLCD_write(NOKIA_LCD_DATA, displayMap[i]);
	}
}

void nokiaLCD_clearDisplay (uint8_t bw)
{
  for (int i=0; i<(NOKIA_LCD_X * NOKIA_LCD_Y / 8); i++)
  {
    if (bw)
      displayMap[i] = 0xFF;
    else
      displayMap[i] = 0;
  }

  nokiaLCD_updateDisplay();
}

void nokiaLCD_setChar(char character, int x, int y, uint8_t bw)
{
  uint8_t column; // temp byte to store character's column bitmap
  for (int i=0; i<5; i++) // 5 columns (x) per character
  {
    column = ASCII[character - 0x20][i];
    for (int j=0; j<8; j++) // 8 rows (y) per character
    {
      if (column & (0x01 << j)) // test bits to set pixels
        nokiaLCD_setPixel(x+i, y+j, bw);
      else
        nokiaLCD_setPixel(x+i, y+j, !bw);
    }
  }
}

void nokiaLCD_setStr(char * dString, int x, int y, uint8_t bw)
{
  while (*dString != 0x00) // loop until null terminator
  {
    nokiaLCD_setChar(*dString++, x, y, bw);
    x+=5;
    for (int i=y; i<y+8; i++)
    {
      nokiaLCD_setPixel(x, i, !bw);
    }
    x++;
    if (x > (NOKIA_LCD_X - 5)) // Enables wrap around
    {
      x = 0;
      y += 8;
    }
  }
}

void nokiaLCD_invertDisplay(void)
{
  /* Direct LCD Command option
  nokiaLCD_write(NOKIA_LCD_COMMAND, 0x20); //Tell LCD that extended commands follow
  nokiaLCD_write(NOKIA_LCD_COMMAND, 0x08 | 0x05); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  nokiaLCD_write(NOKIA_LCD_COMMAND, 0x20); //Set display mode */

  for (int i=0; i < (NOKIA_LCD_X * NOKIA_LCD_Y / 8); i++)
  {
    displayMap[i] = ~displayMap[i] & 0xFF;
  }
  nokiaLCD_updateDisplay();
}

void nokiaLCD_setLine(int x0, int y0, int x1, int y1, uint8_t bw)
{
  int dy = y1 - y0; // Difference between y0 and y1
  int dx = x1 - x0; // Difference between x0 and x1
  int stepx, stepy;

  if (dy < 0)
  {
    dy = -dy;
    stepy = -1;
  }
  else
    stepy = 1;

  if (dx < 0)
  {
    dx = -dx;
    stepx = -1;
  }
  else
    stepx = 1;

  dy <<= 1; // dy is now 2*dy
  dx <<= 1; // dx is now 2*dx
  nokiaLCD_setPixel(x0, y0, bw); // Draw the first pixel.

  if (dx > dy)
  {
    int fraction = dy - (dx >> 1);
    while (x0 != x1)
    {
      if (fraction >= 0)
      {
        y0 += stepy;
        fraction -= dx;
      }
      x0 += stepx;
      fraction += dy;
      nokiaLCD_setPixel(x0, y0, bw);
    }
  }
  else
  {
    int fraction = dx - (dy >> 1);
    while (y0 != y1)
    {
      if (fraction >= 0)
      {
        x0 += stepx;
        fraction -= dy;
      }
      y0 += stepy;
      fraction += dx;
      nokiaLCD_setPixel(x0, y0, bw);
    }
  }
}

void nokiaLCD_setRect(int x0, int y0, int x1, int y1, uint8_t fill, uint8_t bw)
{
	// check if the rectangle is to be filled
	if (fill == 1)
	{
		int xDiff;

		if(x0 > x1)
			xDiff = x0 - x1; //Find the difference between the x vars
		else
			xDiff = x1 - x0;

		while(xDiff > 0)
		{
			nokiaLCD_setLine(x0, y0, x0, y1, bw);

			if(x0 > x1)
				x0--;
			else
				x0++;

			xDiff--;
		}
	}
	else
	{
		// best way to draw an unfilled rectangle is to draw four lines
		nokiaLCD_setLine(x0, y0, x1, y0, bw);
		nokiaLCD_setLine(x0, y1, x1, y1, bw);
		nokiaLCD_setLine(x0, y0, x0, y1, bw);
		nokiaLCD_setLine(x1, y0, x1, y1, bw);
	}
}

void nokiaLCD_setCircle (int x0, int y0, int radius, uint8_t bw, int lineThickness)
{
  for(int r = 0; r < lineThickness; r++)
  {
    int f = 1 - radius;
    int ddF_x = 0;
    int ddF_y = -2 * radius;
    int x = 0;
    int y = radius;

    nokiaLCD_setPixel(x0, y0 + radius, bw);
    nokiaLCD_setPixel(x0, y0 - radius, bw);
    nokiaLCD_setPixel(x0 + radius, y0, bw);
    nokiaLCD_setPixel(x0 - radius, y0, bw);

    while(x < y)
    {
      if(f >= 0)
      {
        y--;
        ddF_y += 2;
        f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x + 1;

      nokiaLCD_setPixel(x0 + x, y0 + y, bw);
      nokiaLCD_setPixel(x0 - x, y0 + y, bw);
      nokiaLCD_setPixel(x0 + x, y0 - y, bw);
      nokiaLCD_setPixel(x0 - x, y0 - y, bw);
      nokiaLCD_setPixel(x0 + y, y0 + x, bw);
      nokiaLCD_setPixel(x0 - y, y0 + x, bw);
      nokiaLCD_setPixel(x0 + y, y0 - x, bw);
      nokiaLCD_setPixel(x0 - y, y0 - x, bw);
    }
    radius--;
  }
}

void nokiaLCD_setBitmap(const char * bitArray)
{
  for (int i=0; i<(NOKIA_LCD_X * NOKIA_LCD_Y / 8); i++)
  {
    char c = bitArray[i];
    displayMap[i] = c;
  }
}

static void nokiaLCD_delay (uint8_t sec)
{
	for (int var = 0; (var < (12000000 * sec)); ++var)
	{

	}
}

static void nokiaLCD_gotoXY (int x, int y)
{
	nokiaLCD_write(0, 0x80 | x);  // Column.
	nokiaLCD_write(0, 0x40 | y);  // Row.  ?
}

static void nokiaLCD_setPixel(int x, int y, uint8_t bw)
{
  // First, double check that the coordinate is in range.
  if ((x >= 0) && (x < NOKIA_LCD_X) && (y >= 0) && (y < NOKIA_LCD_Y))
  {
    uint8_t shift = y % 8;

    if (bw) // If black, set the bit.
      displayMap[x + (y/8)*NOKIA_LCD_X] |= 1<<shift;
    else   // If white clear the bit.
      displayMap[x + (y/8)*NOKIA_LCD_X] &= ~(1<<shift);
  }
}
